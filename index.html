
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="./node_modules/leaflet/dist/leaflet.css" />

    <script src="./node_modules/leaflet/dist/leaflet.js"></script>
    <script src="./node_modules/d3/d3.min.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/lodash.js/1.0.0-rc.3/lodash.underscore.min.js"></script>

    <script type="text/javascript" src="js/colorbrewer.js"></script>
    <script type="text/javascript" src="js/leaflet.points-layer.js"></script>

    <style type="text/css">
      html, body { 
        margin: 0;
        padding: 0;
        height: 100%;
      }

      #map { 
        height: 365px;
        width: 960px;
        margin-bottom: 1em;
      }

      .leaflet-popup-content ul { padding-left: 1.5em; }

      .circle { visibility: hidden; }
      .circle.selected { visibility: visible; }

      svg {
        font: 10px sans-serif;
      }

      .axis path, .axis line {
        fill: none;
        stroke: #000;
        shape-rendering: crispEdges;
      }
    </style>
  </head>
  <body>
    <div id='map' data-source="./data-timeseries.geo.json"></div>
    <script type="text/javascript">
    (function () {
        var extent, scale,
            classes = 5, scheme_id = "YlGn",
            reverse = false;
            scheme = colorbrewer[scheme_id][classes],
            container = L.DomUtil.get('map'),
            map = L.map(container).setView([48.88179184157838, 2.3561596870422363], 16);
        map.on('click', function(ev){
            console.log(ev.latlng.lng + ',' + ev.latlng.lat);
        });
        L.tileLayer('http://{s}.tile.stamen.com/toner/{z}/{x}/{y}.png', {
            attribution: '<a href="http://content.stamen.com/dotspotting_toner_cartography_available_for_download">Stamen Toner</a>, <a href="http://www.openstreetmap.org/">OpenStreetMap</a>, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>',
            maxZoom: 19,
        }).addTo(map);

        d3.json(container.dataset.source, function(collection) {
            
            L.pointsLayer(collection, {
                radius: get_radius,
                applyStyle: circle_style
            }).addTo(map);

            var chart = timeseries_chart(scheme)
                    .x(get_time).xLabel("Time")
                    .y(get_value).yLabel("Indicateur")
                    .brushmove(on_brush);

            d3.select("body").datum(collection.features).call(chart);
        });

        function get_time(d) {
            return d3.time.format(d.properties.time);
        }

        function get_value(d) {
            return Math.round(+d.properties.val);
        }

        function on_brush(brush) {
            var s = brush.extent();
            d3.selectAll(".circle").classed("selected", function (d) {
                var time = get_time(d);
                return s[0] <= time && time <= s[1];
            });
        }
        function get_color(d){
            // var val = (scale(+d.properties.val));
            var val = Math.round(+d.properties.val);
            return scheme[val];
        }

        function get_radius(d) {
            return d.properties.val;
        }

        function circle_style(circles) {
            if (!(extent && scale)) {
                extent = d3.extent(circles.data(), function (d) { return d.properties.val; });
                scale = d3.scale.log()
                        .domain(reverse ? extent.reverse() : extent)
                        .range(d3.range(classes));
            }
            circles.attr('opacity', 0.4)
                .attr('stroke', scheme[classes - 1])
                .attr('stroke-width', 1)
                .attr('fill', get_color);

            circles.on('click', function (d, i) {
                L.DomEvent.stopPropagation(d3.event);

                var t = '<h3><%- id %></h3>' +
                        '<ul>' +
                        '<li>Value: <%- val %></li>'
                        '</ul>';

                var data = {
                        id: d.id,
                        val: d.properties.val
                    };

                L.popup()
                    .setLatLng([d.geometry.coordinates[1], d.geometry.coordinates[0]])
                    .setContent(_.template(t, data))
                    .openOn(map);

            });
        }

        function timeseries_chart(color) {
            var margin = { top: 5, right: 5, bottom: 40, left: 45 },
                width = 960 - margin.left - margin.right,
                height = 80;

            var x = d3.time.scale(),
                y = d3.scale.linear(),
                x_label = "X", y_label = "Y",
                brush = d3.svg.brush().x(x).on("brush", _brushmove);

            var get_x = no_op,
                get_y = no_op;

            function timeseries(selection) {

                selection.each(function (data) {
                    var stats = {};
                    data.forEach(function(d){
                        var val = get_y(d);
                        stats[val] = (stats[val] || 0) + 1;
                    });

                    x.range([0, width]);
                    y.range([height, 0]);

                    var series = d3.select(this).append("svg")
                            // .attr("id", "quake-timeseries")
                            .attr("width", width + margin.left + margin.right)
                            .attr("height", height + margin.top + margin.bottom)
                            .append("g").attr("id", "date-brush")
                            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

                    var x_axis = series.append("g")
                            .attr("class", "x axis")
                            .attr("transform", "translate(0," + height + ")");

                    var y_axis = series.append("g")
                            .attr("class", "y axis");

                    x_axis.append("text")
                        .attr("class", "label")
                        .attr("x", width)
                        .attr("y", 30)
                        .style("text-anchor", "end")
                        .text(x_label);

                    y_axis.append("text")
                        .attr("class", "label")
                        .attr("transform", "rotate(-90)")
                        .attr("y", -40)
                        .attr("dy", ".71em")
                        .style("text-anchor", "end")
                        .text(y_label);

                    series.append("clipPath")
                        .attr("id", "clip")
                        .append("rect")
                        .attr("width", width - 1)
                        .attr("height", height - .25)
                        .attr("transform", "translate(1,0)");

                    series.append("g")
                            .attr("class", "brush")
                            .call(brush)
                            .selectAll("rect")
                            .attr("height", height)
                            .style("stroke-width", 1)
                            .style("stroke", color[color.length - 1])
                            .style("fill", color[color.length - 1])
                            .attr("opacity", 0.4);

                    x.domain(d3.extent(data, get_x));
                    x_axis.call(d3.svg.axis().scale(x).orient("bottom"));

                    y.domain(d3.extent(data, get_y));
                    y_axis.call(d3.svg.axis().scale(y).orient("left"));

                    series.append("g").attr("class", "timeseries")
                        .attr("clip-path", "url(#clip)")
                        .selectAll("circle")
                        .data(data).enter()
                        .append("circle")
                        .style("stroke", 'transparent')
                        .style("stroke-width", 0)
                        .style("fill", get_color)
                        .attr("opacity", function(d){
                            return Math.random() * 0.5; 
                        })
                        .attr("r", function(d){
                            return Math.round(Math.random() * 5); 
                        })
                        .attr("transform", function (d) {
                            return "translate(" + x(get_x(d)) + "," + y(get_y(d)) + ")";
                        });
                });
            }

            timeseries.x = function (accessor) {
                if (!arguments.length) return get_x;
                get_x = accessor;
                return timeseries;
            };

            timeseries.y = function (accessor) {
                if (!arguments.length) return get_y;
                get_y = accessor;
                return timeseries;
            };

            timeseries.xLabel = function (label) {
                if (!arguments.length) return x_label;
                x_label = label;
                return timeseries;
            }

            timeseries.yLabel = function (label) {
                if (!arguments.length) return y_label;
                y_label = label;
                return timeseries;
            }

            timeseries.brushmove = function (cb) {
                if (!arguments.length) return brushmove;
                brushmove = cb;
                return timeseries;
            };

            function _brushmove() {
                brushmove.call(null, brush);
            }

            function no_op() {}

            return timeseries;
        }
    }());
    </script>
  </body>
</html>